<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%230f3460'/><circle cx='8' cy='8' r='6' fill='%23e94560'/><circle cx='16' cy='8' r='5' fill='%23d63447'/><circle cx='24' cy='8' r='5' fill='%23d63447'/><circle cx='24' cy='16' r='5' fill='%23d63447'/><circle cx='24' cy='24' r='5' fill='%23d63447'/><circle cx='7' cy='8' r='1.5' fill='white'/><circle cx='9' cy='8' r='1.5' fill='white'/></svg>">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            touch-action: none;
            user-select: none;
        }
        .game-container {
            text-align: center;
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        canvas {
            border: 2px solid #0f3460;
            background: #0f3460;
            display: block;
            margin: 0 auto;
            outline: none;
            touch-action: none;
        }
        .mobile-controls {
            display: none;
            margin-top: 20px;
            text-align: center;
            color: #e94560;
            font-size: 14px;
        }
        @media (max-width: 600px) {
            .game-container {
                padding: 10px;
                margin: 10px;
            }
            canvas {
                max-width: 90vw;
                max-height: 90vw;
            }
            .mobile-controls {
                display: block;
            }
        }
        .score {
            color: #e94560;
            font-size: 24px;
            margin: 10px 0;
        }
        .game-over {
            color: #e94560;
            font-size: 32px;
            margin: 20px 0;
        }
        .restart-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        .restart-btn:hover {
            background: #d63447;
        }
        .speed-selector {
            margin: 15px 0;
            color: #e94560;
            font-size: 16px;
        }
        .speed-selector select {
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            margin-left: 10px;
        }
        .speed-selector select:focus {
            outline: none;
            border-color: #d63447;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="score">Score: <span id="score">0</span> | High Score: <span id="highScore">0</span></div>
        <div class="speed-selector">
            Speed Level:
            <select id="speedLevel">
                <option value="simple">Simple (Slow)</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard (Fast)</option>
            </select>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div class="mobile-controls">
            Swipe to control snake direction
        </div>
        <div id="gameOver" class="game-over" style="display: none;">
            Game Over!
            <br>
            <button class="restart-btn" onclick="restartGame()">Restart</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const speedSelector = document.getElementById('speedLevel');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let snake = [
            {x: 10, y: 10}
        ];
        let food = {};
        let dx = 0;
        let dy = 0;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameRunning = true;
        let gameInterval;
        let currentSpeed = 'normal';
        let gimmick = null;
        let gimmickTimer = 0;
        let gimmickCooldown = 100; // appear every ~20 seconds at normal speed
        let gimmickDuration = 150; // disappear after ~30 seconds at normal speed
        let gimmickActive = false;
        let shortestPathDistance = 0;
        let actualPathDistance = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        const speedSettings = {
            simple: 300,
            normal: 200,
            hard: 120
        };

        function generateFood() {
            food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
            calculateShortestPath();
        }
        
        function generateGimmick() {
            let attempts = 0;
            do {
                gimmick = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                attempts++;
            } while ((gimmick.x === food.x && gimmick.y === food.y) || 
                     isPositionOnSnake(gimmick) && attempts < 50);
            
            gimmickActive = true;
            gimmickTimer = 0;
            calculateShortestPath();
        }
        
        function isPositionOnSnake(pos) {
            return snake.some(segment => segment.x === pos.x && segment.y === pos.y);
        }
        
        function calculateShortestPath() {
            const head = snake[0];
            const target = gimmickActive ? gimmick : food;
            shortestPathDistance = Math.abs(head.x - target.x) + Math.abs(head.y - target.y);
            actualPathDistance = 0;
        }

        function drawGame() {
            clearCanvas();
            drawGrid();
            drawSnake();
            drawFood();
            if (gimmickActive) {
                drawGimmick();
            }
            moveSnake();
            checkCollision();
            updateGimmickTimer();
        }

        function clearCanvas() {
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawGrid() {
            ctx.strokeStyle = '#1a4480';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
        }

        function drawSnake() {
            snake.forEach((segment, index) => {
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;
                
                if (index === 0) {
                    // Draw snake head
                    ctx.fillStyle = '#e94560';
                    ctx.beginPath();
                    ctx.arc(x + gridSize/2, y + gridSize/2, gridSize/2 - 1, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw eyes
                    ctx.fillStyle = 'white';
                    const eyeOffset = gridSize/4;
                    const eyeSize = 2;
                    
                    if (dx === 1) { // facing right
                        ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                    } else if (dx === -1) { // facing left
                        ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(x + eyeOffset, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                    } else if (dy === -1) { // facing up
                        ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + eyeOffset, eyeSize, eyeSize);
                    } else { // facing down or stationary
                        ctx.fillRect(x + eyeOffset, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                        ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                    }
                } else {
                    // Draw snake body
                    ctx.fillStyle = '#d63447';
                    ctx.fillRect(x + 1, y + 1, gridSize - 2, gridSize - 2);
                    ctx.strokeStyle = '#e94560';
                    ctx.strokeRect(x + 1, y + 1, gridSize - 2, gridSize - 2);
                }
            });
        }

        function drawFood() {
            const x = food.x * gridSize + gridSize/2;
            const y = food.y * gridSize + gridSize/2;
            
            // Draw mobile phone
            const phoneWidth = gridSize * 0.5;
            const phoneHeight = gridSize * 0.8;
            
            // Phone body - bright silver/white
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(x - phoneWidth/2, y - phoneHeight/2, phoneWidth, phoneHeight);
            
            // Phone bezel
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - phoneWidth/2, y - phoneHeight/2, phoneWidth, phoneHeight);
            
            // Screen - bright green (like WhatsApp or tech green)
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(x - phoneWidth/2 + 2, y - phoneHeight/2 + 3, phoneWidth - 4, phoneHeight - 8);
            
            // Screen shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(x - phoneWidth/2 + 2, y - phoneHeight/2 + 3, phoneWidth - 4, 3);
            
            // Home button
            ctx.fillStyle = '#95a5a6';
            ctx.beginPath();
            ctx.arc(x, y + phoneHeight/2 - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Top speaker
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(x - phoneWidth/4, y - phoneHeight/2 + 1, phoneWidth/2, 1);
        }
        
        function drawGimmick() {
            const x = gimmick.x * gridSize + gridSize/2;
            const y = gimmick.y * gridSize + gridSize/2;
            
            // Pulsing effect
            const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
            
            // Draw golden star
            ctx.fillStyle = '#ffd700';
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(pulseScale, pulseScale);
            
            // Draw 5-pointed star
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const radius = i % 2 === 0 ? gridSize/3 : gridSize/6;
                const px = Math.cos(angle) * radius;
                const py = Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Add sparkle effect
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-1, -1, 2, 2);
            
            ctx.restore();
        }

        function moveSnake() {
            if (dx === 0 && dy === 0) return;

            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            actualPathDistance++;

            // Check collision with new head position BEFORE moving
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // Check self collision with new head position
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            let ate = false;

            // Check gimmick collision
            if (gimmickActive && head.x === gimmick.x && head.y === gimmick.y) {
                score += 20; // Double the normal food score
                scoreElement.textContent = score;
                
                // Reduce snake length by 50% BEFORE adding new head
                const newLength = Math.max(1, Math.floor(snake.length / 2));
                snake.splice(newLength); // Remove segments from the end
                
                // Add the new head
                snake.unshift(head);
                
                gimmickActive = false;
                gimmick = null;
                gimmickTimer = 0;
                calculateShortestPath();
                return; // Exit early since we already added the head
            }
            // Check food collision
            else if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreElement.textContent = score;
                generateFood();
                ate = true;
            }

            snake.unshift(head);

            if (!ate) {
                snake.pop();
            }
        }

        function checkCollision() {
            // Collision detection is now handled in moveSnake() function
            // This function is kept for compatibility but does nothing
        }

        function gameOver() {
            gameRunning = false;
            stopGameLoop();
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            gameOverElement.style.display = 'block';
        }

        function restartGame() {
            snake = [{x: 10, y: 10}];
            dx = 0;
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            gameRunning = true;
            gameOverElement.style.display = 'none';
            gimmick = null;
            gimmickActive = false;
            gimmickTimer = 0;
            generateFood();
            startGameLoop();
            canvas.focus();
        }
        
        function startGameLoop() {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            gameInterval = setInterval(drawGame, speedSettings[currentSpeed]);
        }
        
        function stopGameLoop() {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            const newDx = dx;
            const newDy = dy;

            switch(e.key) {
                case 'ArrowUp':
                    if (dy !== 1) {
                        dx = 0;
                        dy = -1;
                    }
                    break;
                case 'ArrowDown':
                    if (dy !== -1) {
                        dx = 0;
                        dy = 1;
                    }
                    break;
                case 'ArrowLeft':
                    if (dx !== 1) {
                        dx = -1;
                        dy = 0;
                    }
                    break;
                case 'ArrowRight':
                    if (dx !== -1) {
                        dx = 1;
                        dy = 0;
                    }
                    break;
            }
        });

        function wouldCollideWithSelf(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        speedSelector.addEventListener('change', (e) => {
            currentSpeed = e.target.value;
            if (gameRunning) {
                startGameLoop();
            }
            canvas.focus();
        });
        
        function updateGimmickTimer() {
            if (!gimmickActive) {
                gimmickTimer++;
                if (gimmickTimer >= gimmickCooldown) {
                    generateGimmick();
                }
            } else {
                gimmickTimer++;
                if (gimmickTimer >= gimmickDuration) {
                    gimmickActive = false;
                    gimmick = null;
                    gimmickTimer = 0;
                }
            }
        }
        
        // Touch event handlers
        canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touch = e.changedTouches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30;
            
            if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                return;
            }
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 0) {
                    // Swipe right
                    if (dx !== -1) {
                        dx = 1;
                        dy = 0;
                    }
                } else {
                    // Swipe left
                    if (dx !== 1) {
                        dx = -1;
                        dy = 0;
                    }
                }
            } else {
                // Vertical swipe
                if (deltaY > 0) {
                    // Swipe down
                    if (dy !== -1) {
                        dx = 0;
                        dy = 1;
                    }
                } else {
                    // Swipe up
                    if (dy !== 1) {
                        dx = 0;
                        dy = -1;
                    }
                }
            }
        }
        
        canvas.setAttribute('tabindex', '0');
        canvas.focus();
        
        highScoreElement.textContent = highScore;
        generateFood();
        startGameLoop();
    </script>
</body>
</html>